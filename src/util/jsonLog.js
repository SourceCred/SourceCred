// @flow

import stringify from "json-stable-stringify";
import fs from "fs-extra";
import * as C from "./combo";

/**
 * JsonLog tracks and serializes append-only logs of JSON objects.
 *
 * At its heart, it's basically a simple wrapper around an array, which
 * enforces the rule that items may be appended to it, but never removed.
 *
 * It also provides serialization logic. While the log is an array of JSON
 * objects and thus a JSON object itself, we don't want to store it on disk as
 * a stringified JSON object. That would lose the structure of an append-only
 * array, as every change would result in a rewrite of a single massive line of
 * text, and would be inefficient in Git storage, and make for ugly diffs and
 * merge conflicts.
 *
 * Instead, we store each item on its own line in the output format, using
 * `stringify` on the individual JSON objects. We support // comment syntax,
 * and the toString and writeJsonLog methods allow you to provide prefix
 * comments; we recommend putting prefix comments like
 * ["AUTOGENERATED FILE", "do not manually edit"].
 *
 * The JsonLog is always parsed using a Combo.Parser, which ensures type safety
 * at runtime.
 */
export class JsonLog<T: C.JsonObject> {
  +_items: T[];

  constructor() {
    this._items = [];
  }

  append(items: Iterable<T>): JsonLog<T> {
    for (const item of items) {
      this._items.push(item);
    }
    return this;
  }

  values(): Iterator<T> {
    return this._items.values();
  }

  toString(prefixComments: ?$ReadOnlyArray<string>): string {
    const stringified = this._items.map((x) => stringify(x)).join("\n");
    if (prefixComments != null && prefixComments.length !== 0) {
      const multilineComments = prefixComments.filter(
        (x) => x.indexOf("\n") !== -1
      );
      if (multilineComments.length !== 0) {
        throw new Error(
          "comments may not contain newlines (just split them up)"
        );
      }
      const prelude = prefixComments.map((x) => "// " + x).join("\n") + "\n";
      return prelude + stringified;
    }
    return stringified;
  }

  static fromString(log: string, parser: C.Parser<T>): JsonLog<T> {
    const lines = log
      .split("\n")
      .filter((x) => x.length !== 0 && !x.startsWith("//"));
    const objects: C.JsonObject[] = lines.map((x) => JSON.parse(x));
    const items: T[] = objects.map((e) => parser.parseOrThrow(e));
    return new JsonLog().append(items);
  }

  async writeJsonLog(
    path: string,
    comments: ?$ReadOnlyArray<string>
  ): Promise<void> {
    const logString = this.toString(comments);
    await fs.writeFile(path, logString);
  }

  static async readJsonLog(
    path: string,
    parser: C.Parser<T>
  ): Promise<JsonLog<T>> {
    const logString = await fs.readFile(path);
    return JsonLog.fromString(logString.toString(), parser);
  }
}
