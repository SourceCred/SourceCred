// @flow

/**
 * This module has a core data type identifying SourceCred identities.
 *
 * The scope for this data type is to model:
 * - a unique identifier for each identity
 * - a unique (renameable) identityName they choose
 * - the address of every node they correspond to in the graph
 *
 * Unlike most other state in SourceCred, the Identity state is
 * nondeterministically generated by SourceCred itself, and then persisted
 * long-term within the instance.
 *
 * This is in contrast to Graph data, which usually comes from an external
 * source, and is not persisted long-term, but instead is re-generated when
 * needed.
 *
 * In particular, this kernel of identity data is stored within the core ledger,
 * since it's necessary to track consistently when tracking Grain distribution.
 * This type should not grow to include all the data that the UI will
 * eventually want to show; that should be kept in a different data store which
 * isn't being used as a transaction ledger.
 *
 */
import {
  type Uuid,
  parser as uuidParser,
  random as randomUuid,
} from "../util/uuid";
import * as C from "../util/combo";
import {
  type NodeAddressT,
  NodeAddress,
  type Node as GraphNode,
} from "../core/graph";

/**
 * We validate identityNames using GitHub-esque rules.
 *
 * IdentityNames are always lower-case.
 */
export opaque type IdentityName: string = string;
const IDENTITY_NAME_PATTERN = /^[A-Za-z0-9-]+$/;

export type IdentityId = Uuid;
export type Identity = {|
  // UUID, assigned when the identity is created.
  +id: IdentityId,
  +name: IdentityName,
  // The identity's own node address.
  +address: NodeAddressT,
  // Every other node in the graph that this identity corresponds to.
  // Does not include the identity's "own" address, i.e. the result
  // of calling (identityAddress(identity.id)).
  +aliases: $ReadOnlyArray<NodeAddressT>,
|};

export function newIdentity(name: string): Identity {
  const id = randomUuid();
  return {
    id,
    address: NodeAddress.append(IDENTITY_PREFIX, id),
    name: identityNameFromString(name),
    aliases: [],
  };
}

// It's not in the typical [owner, name] format because it isn't provided by a plugin.
// Instead, it's a raw type owned by SourceCred project.
export const IDENTITY_PREFIX = NodeAddress.fromParts([
  "sourcecred",
  "core",
  "IDENTITY",
]);

/**
 * Parse a IdentityName from a string.
 *
 * Throws an error if the identityName is invalid.
 */
export function identityNameFromString(identityName: string): IdentityName {
  if (!identityName.match(IDENTITY_NAME_PATTERN)) {
    throw new Error(`invalid identityName: ${identityName}`);
  }
  return identityName.toLowerCase();
}

export function graphNode({name, address}: Identity): GraphNode {
  return {
    address,
    description: name,
    timestampMs: null,
  };
}

export const identityNameParser: C.Parser<IdentityName> = C.fmap(
  C.string,
  identityNameFromString
);

export const identityParser: C.Parser<Identity> = C.object({
  id: uuidParser,
  name: identityNameParser,
  address: NodeAddress.parser,
  aliases: C.array(NodeAddress.parser),
});
